Эмулятор многоленточной машины Тьюринга
=======================================

Настоящий документ содержит описание принципа работы эмулятора. Показана структура 32-битного правила перехода, приведён алгоритм на псевдокоде. Показана эффективность применения данного метода по сравнению с традиционным подходом.

Это позволяет разработать генератор случайных правильных программ для машины Тьюринга и показать отличия в скорости работы эвристического анализатора машины Тьюринга, который верифицирует программы на соответствие вычислимой функции.

На вход генератору предоставляется формальная запись функции, преобразующая входные данные в выходные. Генератор должен подобрать программу для машины Тьюринга, которая вычисляет заданную функцию. Генератор должен предоставлять исходный код программы для компилятора MTRС, который будет скомпилирован в объектный модуль.

Для эвристического анализатора требуется предварительно скомпилированный модуль с процедурой, транслирующей 32 битный код состояния в инструкции для эмулятора.

Для того, чтобы показать эффективность применения для синтаксического анализа, требуется транслятор программ, сгенерированных YACC в код на языке компилятора MTRC.

1. Общий принцип работы эмулятора машины Тьюринга

Эмулятор машины Тьюринга для получения инструкций вида (рис. 1.1) использует процедуры из объектного модуля, который был создан компилятором MTRC.

			 31              23      19      15              7             0
			┌───────────────┬─┬─┬─┬─┬───────┬───────────────┬───────────────┐
	EAX:	│               │ │ │ │ │  dir  │     a_sec     │     a_fst     │
			└───────────────┴─┴─┴─┴─┴───────┴───────────────┴───────────────┘
				    ││        \ \ \ \
					\/	       \ \ \ \── a_fst_const
			┌───┬───────────┐   \ \ \─── a_sec_const
		1)	│   │ q_number  │    \ \──── f_repeat
			└───┴───────────┘     \───── f_norule
			   \
				\── q_flags
	   
			┌───────────────┐
		2)	│  tape_number  │
			└───────────────┘
	   
	        Рисунок 1.1 -- Структура инструкции для эмулятора statestep.lib
	   
Инструкция состоит из нескольких полей.

  1. Целые беззнаковое числа a_fst, a_sec обозначают данные, которые считываются или записываются на ленту.
  2. Число dir (от direction -- направление) обозначает код, используемый для перемещения ленты.
  3. Флаги a_fst_const, a_sec_const указывают интерпретатору, что запись на первую или вторую ленту не происходит.
  4. Флаг f_repeat (от repeat -- повтор) указывает, что для окончания такта нужно выполнить ещё одну инструкцию.
  5. Флаг f_norule (от no rule -- не правило) указывает, что инструкция не является правилом перехода.
  6. Число tape_number -- номер пары лент.
  7. Число q_number обозначает младшие 6 бит номера состояния или специального кода.
  8. Число q_flags обозначает, как нужно интерпретировать q_number.
  
1.1 Общий принцип интерпретации инструкций для statestep.lib.

В памяти хранятся определённое число буферов. Обозначим их $1, $2, и т. д. Каждый буфер представляет собой последовательность байтов или символов в определённой кодировке. Номера лент, на которых производятся действия, связан с номером пары лент (tape_number) так, как показано в таблице 1.1.

			  Таблица 1.1 -- Смысл числа tape_number
 +-------------+-----------------+-----------------+
 | tape_number | Лента для a_fst | Лента для a_sec |
 |			   | и a_fst_const   | и a_sec_const   |
 +-------------+-----------------+-----------------+
 |      0      |        $1       |        $2       |
 |      1      |        $3       |        $4       |
 |      2      |        $5       |        $6       |
 |     ...     |       ...       |       ...       |
 +-------------+-----------------+-----------------+

Каждая инструкция относится к определённой паре лент. 
  
Возможные значения q_flags:
  -- 00
  -- 01
  -- 10
  -- 11
